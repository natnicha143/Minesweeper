\documentclass[12pt, a4]{report}
\usepackage[utf8]{inputenc}
\usepackage[margin=0.8in]{geometry}
\def\thesection{\arabic{section}}
\setcounter{tocdepth}{4}
\usepackage{graphicx}
\graphicspath{ {images/} }
% Below are for the code blocks
\usepackage{listings}
\usepackage{courier}
\usepackage{verbatim}
\usepackage{color}
\usepackage{rotating}

% Below are table config
\setlength{\arrayrulewidth}{0.5mm}
\setlength{\tabcolsep}{10pt}
\renewcommand{\arraystretch}{1.5}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.5,0.92}
\definecolor{bittersweet}{rgb}{1.0, 0.44, 0.37}
\definecolor{cosmiclatte}{rgb}{0.93, 0.93, 0.93}
\definecolor{eggshell}{rgb}{0.94, 0.94, 0.9}
\definecolor{fandango}{rgb}{0.71, 0.2, 0.54}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{cosmiclatte},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{fandango}\small,
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,        
	breaklines=true,               
	captionpos=b,                    
	keepspaces=true,  
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}

\lstset{style=mystyle}

\title{2805ICT, Minesweeper Project}
\author{Natnicha Titiphanpong, s2940970}%\thanks{}}
\date{\today}

\begin{document}
\begin{titlepage}
	\maketitle 
\end{titlepage}
	\tableofcontents
	\pagebreak
	\section{Minesweeper} 
	\subsection{Fully Functional Implementation of Task 1}
	Link: https://youtu.be/d5HWxtuCzrk 
		\begin{figure}[!h]
			\centering
			\includegraphics[scale=0.7]{menu}
			\caption{Main menu for mine sweeper: ability to choose difficulty}
		\end{figure}
	
		\begin{figure}[!h]
			\centering
			\includegraphics[scale=0.7]{game}
			\caption{Intermediate mode for mine sweeper game: 16 x 16 with 40 mines}
		\end{figure}
	\par The current  version of minesweeper successfully meets the requirements of the traditional minesweeper game. 
 
		\newpage
	\subsection{Cross platform}
	\par The programming language chosen - Python allows the program to be executable on Windows and Linux. The Graphic User Interface (GUI) modules are available to both platforms. Therefore, when creating a program that requires a GUI, Python was considered first when accounting for cross-platform applications. 
	Link: https://youtu.be/Hnfs919bH2s
	
	\section{Software Development Practices}
	\subsection{Version Control History / Log}
	\begin{tabular}{ | p{3cm} | p{2cm} | p{11cm} | }
		\hline
		Date & User & Activity \\
		\hline
		Sep 22, 2017 & Natnicha & Modified button bindings to deal with left and right handler properly. \\
		Sep 22, 2017 & Natnicha & Ajusted model to refer to boolean list for toggled and flagged for left and right click. \\
		Sep 21, 2017 & Natnicha & Finalised MainMenu class. Destroys Frame after selecting difficulty. \\
		Sep 20, 2017 & Natnicha & MainMenu class: created set difficulty function to be passed to the model. \\
		Sep 19, 2017 & Natnicha & Finalised Button Controller class to be a Facade for model. \\
		Sep 15, 2017 & Natnicha & Imported images for Main Menu. \\
		Sep 5, 2017 & Natnicha & Made all views extend tkinter.Frame. \\
		Sep 5, 2017 & Natnicha & Added MainMenu class, extends tkinter.Frame. \\ 
		Sep 4, 2017 & Natnicha & Resolved Merging conflict. \\ 
		\hline
	\end{tabular}

	\begin{tabular}{ | p{3cm} | p{2cm} | p{11cm} | }
		\hline
		Sep 4, 2017 & Natnicha & Added diagrams to Report \\ 
		Sep 3, 2017 & Natnicha & Separated create board function in three separate functions for low coupling, removed nested functions. \\ 
		Sep 2, 2017 & Natnicha & Added UML section to report. Put MV files into classes. \\ 
		Sep 1, 2017 & Natnicha & Added timer and reset button functions to Program. \\ 
		Sep 1, 2017 & Natnicha & Added test section to Report. \\ 
		Aug 31, 2017 & Natnicha & Modified test file and fixed formatting in report. Restructured program into MVC architecture. \\ 
		Aug 31, 2017 & Natnicha & Merging conflict resolved. \\
		Aug 31, 2017 & Natnicha & Merging files \\ 
		Aug 30, 2017 & Natnicha & Modified Software Architecture section in Report. \\ 
		Aug 30, 2017 & Natnicha & Completed use case progression and added software architecture section to Report. \\ 
		Aug 30, 2017 & Natnicha & Added more use cases. \\ 
		Aug 30, 2017 & Natnicha & Modified activation button function to handle functionality depending on the backing grid \\ 
		Aug 29, 2017 & Natnicha & Added game end function to handle the program when the game is over. \\ 
		Aug 29, 2017 &Natnicha & Fixed cascading reveal to display empty cells and cells adjacent to. \\ 
		Aug 29, 2017 & Natnicha & Added colour scheme to GUI minesweeper.py \\
		Aug 26, 2017 & Natnicha & Added images to buttons for GUI. \\ 
		\hline
	\end{tabular}
	
	\par \vspace{1cm}\small Note: Repository is private. \textbar{} This log was created by using the command \begin{lstlisting} 
	git log --pretty=format:`%h;%an;%s' > ./log.csv\end{lstlisting}
	
	The development of this program required the use of version control software to save versions of the project and also to monitor/measure productivity. GitHub was created as an online hosting solution for git repositories. Git records a log of past commits pushed to the repository which allows for backtracking of file versions.
	\section{Design Principles}
	\subsection{Least privilege and fail-safe defaults}
	\par There are no  security risks involved with playing the minesweeper game, all users may access and play the game. Fail-safe defaults implies a basic lack of access for all users
	unless the condition of the user is identified with a permission. The users may not access anything beyond the two views of the game: MainMenu and SquareView and cannot 
	access any underlying data of the game, only what is necessary to play the game. 
	
	\subsection{Separation of concerns and information hiding}
	\par One of the most important principles in software engineering is the separation of concerns. It follows the idea of avoiding co-locating different concerns within the software, which
	ensures the program is less likely to violate the Don't Repeat Yourself Principle and become easily maintainable. 
	Between the GameModel and SquareView classes, the logic for determining what numbers to display on the board, the position of the mines are all done in the model whereas the
	formatting or configuration of the buttons to display once the data has changed is done in the view. If formatting and mutating of data was done in the same class, it would violate
	the concept of separation of concerns. Alike separation of concerns, information hiding separates the class' details from the object and only enable us to work with the object. 
	By keeping the details of how an object accomplishes what its API states hidden enables us to treat the object as a black box. The controller doesn't need to know what the model looks like,
	it just needs to be the bridge between the view and controller, where the coordinates of each button are passed from the view to the model so the model knows how to change accordingly. 
	
	\subsection{Coupling, cohesion and encapsulation}
	\par For software engineers, the two most important factors about a program are its degree of coupling and cohesion. We always want low coupling where the dependency is minimal
	between two modules. On the contrary for cohesion, it is a high-degree of cohesion that engineers strive for. The program's subsystems should be split into how strongly-related they are to one another.
	In the MainMenu class, only the GUI of the buttons is done and the purpose of the main menu is to pass the height, width and mines variable to the model so that it can create the
	game's format according to its level of difficulty. The MainMenu class is one of the two existing views in the program, even if both SquareView and MainMenu view extend tkinter.Frame
	and handle the GUI, their purposes are completely different. One class initiates the game model and the other continually mutates the model.
	
	\section{Design Process}
	\par
	The minesweeper project required a lot of flexibility as the developer had to experiment with programming with GUI and using the Tkinter class with Python along with 
	learning the Model-view controller architecture. The design process used an agile software development method, which is highly preferred in software projects that require
	a lot of tinkering and testing during production. This development process was based on the idea that successful development would happen quickly as testing was done regularly.
	This is true for small projects such as minesweeper as there was less thought about the design of the program, and more regarding functionality. 
	In contrast, the waterfall development process is a more traditional process however, due to the time constraint and also due the low complexity of the system, there was 
	no need to complete processes periodically. The software would have not progressed past programming and unit testing. Using agile development, bugs, 
	complications and feature changes are handled better to meet the requirements.
	
	\section{System Models}

	\begin{figure}[!h]
		\centering
		\includegraphics[scale=0.5]{classdiagram}
		\caption{Class diagram for Python implementation of Minesweeper using MVC architecture}
	\end{figure}
	\pagebreak
	
	\begin{figure}[!h]
		\lstinputlisting[language=Python, firstline=1, lastline=26]{minesweeper.txt}
		\caption{Main class Minesweeper}
	\end{figure}
	
	\par The program creates an object of each class in order of what needed to be called from first. Since the views extend Tkinter's Frame component, 
	the root frame (main frame) needed to be created first for the views to extend. The main menu object was then created as that was the first view 
	for the game as the model needed the variables passed from the main menu view to set the size and difficulty of the board, then the main loop is executed. 
	The user selects a difficulty and the main menu frame is destroyed and the frame is quit, necessary for the while loop to continue. This gives the 
	opportunity to create the model object, which the data is stored, the new view will run along with two new frames: and top frame for the score timer and new game button
	and a bottom frame for the board of buttons. The root then executes the main loop once again. 
	
	\section{Design Paradigm}
	The minesweeper program was written so that if other game modes were required, the engineer would only need to write a new view to display the hexagons and create a function
	to set the coordinates of the hexagons. All other parts of the software can be effectively reused. To create a more intellectually manageable program, modularity is necessary.
	It gives engineers one powerful ability - to be able to test modules individually and when fixing bugs, you know for certain that nothing other than what is in your module is
	broken by the changes you made. Testing the functionality of each button in the view can be done in modules as the affects of the board rely on the underlying number and value of each cell. 
	
	\section{Design Patterns}
	\par The model-view controller heavily uses the Observer pattern especially in the Model and View. When the data in the model class is modified, the view class needs to be notified and updated as it is run. 
	The Board Controller class uses a Facade design pattern. The facade design pattern simplifies the interface to the model, which can be said to be a complex system. It abstracts the implementation and acts like a proxy, shielding the user from the details stored in the model. Instead leaving the controller to manage between the view and controller. This decouples the program that uses the system from the details of the subsystem, increasing efficiency and understanding for modification later on. 

	\section{User Interface}
	The user interface uses an event driven based design. There is an event and a listener, the listener is notified when an event occurs by button click. The event which is bind to the button using an event-handler. The program binds each click to a button. As the player interacts with the game, the game is played with the event of a button press. The event handler function reacts depending on the hidden backing board and the minesweeper board is modified in one of the four different ways. The first way the board can be modified is by clicking a button with a number, which only reveals its own underlying square. The second way is for the square to be empty which checks adjacent squares if they are also empty, this check is done in the cascade reveal function. Thirdly, the underlying cell could be a mine ultimately disabling the state of the board and ending the game. Lastly, the user can flag the square and not activate the button at all but uses the right mouse click event to bind the flag as an overlaying image. 
	
	\section{Software Architecture: Model-View Controller & its importance to UI programming}
	\par Model view controller (MVC) is a type of software architecture that allows different parts of a system to be loosely coupled (or separated). 
	MVC keeps the code well-organised into three distinctly different sections of code. Views display data from the model and take user actions. 
	Models represent the data and domain logic in the system. And controllers liaise between the View and the Model, often controlling flow. 
	MVC have separated functions will solve the most common software problems of today: readability, modularity, and coupling. 
	This helps programmers reuse and change code as they are able to work in smaller subset that may be more or less isolated from the larger piece of code or 
	functionality. This structure also helps when testing the program, especially unit testing when sections of code need to be tested. As similar code is 
	sectioned into groups, there is better coverage of test cases. It is important to use this type of architecture with user interface programming as we want the program
	to separate the application's logic from the rest of the user interface, which is achievable using MVC. The view only needs to focus on rendering data from the model
	into the form implied for the user interface. This gives the model the ability to freely respond to instructions and change the state of its information, and notify users
	in Minesweeper's event-driven system when data changes. 
	
	\section{Good Software Design}
	\par A good software design should correctly implement all the requirements and functionalities defined in Software Requirement Specification document. With no 
	formal methods of design from the start, the software can very quickly become very difficult to manage. 
	We also want to design the software in a way that will ensure the code is reusable. Since each class is a blueprint of the object it creates, 
	the software will have high cohesion, it should only have methods relating to the intention of the class. It is intentionally done this way to make each 
	class purposeful and independent of another. The goal of good software design is to lower coupling so that when a part of software needs to be changed, it does not effect the other. 
	Although the main menu and the game frame may extend the same root Frame, the program calls the individual menu and game frame to destroy 
	and quit while maintaining the root frame to be passed on and used in the next view. Another good software design concept is modularity. All 
	the functions in the view have the sole purpose of configuring the buttons depending on the state of the model, the model does not do any 
	configuration and independently handles and mutates the data. This purpose helps separate the classes that are not responsible for configuring but 
	for mutating and vice versa.After the deployment of the software, it should be able to be maintained and easily amenable to change which leads onto the 
	next topic, different designs. 
	\newpage
	\section{Different Designs}
	\par For software developers to create a variety of different designs for their program, comments 
	illustrate how other developers may extend or enhance the already completed program by explaining the purpose of 
	each function. Comments create the opportunity for developers to reuse code and it is imperative to fully understand a 
	block of code with a single, simple and concise comment. It is the only way to capture the intention of the code at the time of 
	writing, when going back to the program later on, it is more effective to continue and progress if there is are basic explanations documented 
	on the same page. Figure 3 below shows some of the functions in the GameModel class and the associated comments.
	
	\begin{figure}[h]
		\lstinputlisting[language=Python, firstline=28, lastline=59]{minesweeper.txt}
		\caption{Some functions in the GameModel class}
	\end{figure}
	
	
	

\end{document}